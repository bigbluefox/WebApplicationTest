<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Workers基本用法</title>

    <script type="text/javascript">
        
        //http://www.ruanyifeng.com/blog/2018/07/web-worker.html

        //2.1 主线程
        // 主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
        var worker = new Worker('worker.js');

        // Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。
        // 由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。
        // 然后，主线程调用worker.postMessage()方法，向 Worker 发消息。

        worker.postMessage('Hello World');
        worker.postMessage({ method: 'echo', args: ['Work'] });

        //worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。
        //接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。


        worker.onmessage = function (event) {
            console.log('Received message ' + event.data);
            doSomething();
        }

        function doSomething() {
            // 执行任务
            worker.postMessage('Work done!');
        }


        worker.onerror(function (event) {
            console.log([
                'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message
            ].join(''));
        });

        // 或者
        worker.addEventListener('error', function (event) {
            // ...
        });

        //上面代码中，事件对象的data属性可以获取 Worker 发来的数据。
        //Worker 完成任务以后，主线程就可以把它关掉。

        worker.terminate();




        //2.2 Worker 线程
        //Worker 线程内部需要有一个监听函数，监听message事件。

        self.addEventListener('message', function (e) {
            self.postMessage('You said: ' + e.data);
        }, false);

        //上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。

        // 写法一
        this.addEventListener('message', function (e) {
            this.postMessage('You said: ' + e.data);
        }, false);

        // 写法二
        addEventListener('message', function (e) {
            postMessage('You said: ' + e.data);
        }, false);

        //除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。
        //根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。

        self.addEventListener('message', function (e) {
            var data = e.data;
            switch (data.cmd) {
            case 'start':
                self.postMessage('WORKER STARTED: ' + data.msg);
                break;
            case 'stop':
                self.postMessage('WORKER STOPPED: ' + data.msg);
                self.close(); // Terminates the worker.
                break;
            default:
                self.postMessage('Unknown command: ' + data.msg);
            };
        }, false);
        //上面代码中，self.close()用于在 Worker 内部关闭自身。

        //使用完毕，为了节省系统资源，必须关闭 Worker。
        // Worker 线程
        self.close();






    </script>


</head>
<body>

<script id="worker" type="app/worker">
      addEventListener('message', function () {
        postMessage('some message');
      }, false);
    </script>


<script type="text/javascript">
    

    var blob = new Blob([document.querySelector('#worker').textContent]);
    var url = window.URL.createObjectURL(blob);
    var worker = new Worker(url);

    worker.onmessage = function (e) {
        if (window.console) window.console.info(e.data);
        // e.data === 'some message'
    };

</script>


</body>
</html>
